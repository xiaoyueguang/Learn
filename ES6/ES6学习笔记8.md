# 对象的扩展

## 属性的简洁表示法
```
let foo = 'bar';
let obj = {foo};

console.log(obj);   //=> {foo: 'bar'}
```
`ES6` 允许对象中,只写属性名,不写属性值.属性值会自动赋值属性名代表的变量.  
属性可以简写,方法也可以简写
```
let foo = {
    bar(str) {
        console.log('Hello' + str);
    },
    //  Generator函数需要加星号
    *m(){
        yield 'Hello World!';
    }
};
```

## 属性名表达式

```
let obj = {};
obj.foo = true;
obj['bar'] = true;

let key = 'bar';
obj[key] = true;
```
## 方法的name属性

函数的`name`属性可返回函数名.对象的方法同时也具有`name`属性
```
let person = {
    sayName(){
        console.log(this.name);
    },
    get firstName(){
        console.log(this.name);
    }
}

console.log(person.sayName.name);   //=> sayName
console.log(person.firstName.name); //=> get firstName  //  经测试,是 undefined?
```

* `bind`方法创造的函数,`name`返回`bound` 加原函数的名字
* `Function`构造函数创造的函数,`name`属性返回`anonymous`
* 对象的方法是`Symbol`值,`name`返回这个`Symbol`值的描述

## Object.is()
`ES6`提出`Same-value equality`(同值相等)算法,来解决`ES5`并不是很严格的相等判断.
```
+0 === -0;      //=> true
NaN === NaN;    //=> false

Object.is(+0, -0);  //=> false
Object.is(NaN,NaN); //=> true
```

## Object.assign()
#### 基本用法
`Object.assign`方法可将源对象的所有可枚举属性,复制到目标对象.  
目标对象或源对象有多个同名属性,后面的属性会覆盖前面的属性
```
let a = {a:1};
let b = {b:2};
let c = {c:3};
let d = {b:4};

Object.assign(a, b, c, d);
console.log(a); //=> {a:1,b:4,c:3}
```
* 当`Object.assign`只有一个参数,会直接返回该参数.
* 该参数不是对象,则先转成对象,再返回
* `undefined`和`null`无法转成对象,会报错
* 所有参数都会转成对象,若非首参数无法转为对象,则跳过而不报错.
* 非首参数为数值,字符串和布尔值时,也不会报错,字符串会转为数组形式拷贝进入目标对象,其它值无效果
* `Object.assign`只能拷贝自身属性,不拷贝继承属性和不可枚举属性
* 属性名为`Symbol`的属性,也会被拷贝

```
let obj = {a:1};
Object.assign(obj) === obj; //=> true

typeof Object.assign(2);    //=> object

Object.assign(undefined);   //=> error
Object.assign(null);        //=> error

Object.assign({},undefined,'a',1,true);    //=> {'0':'a'}

```

> `Object.assign`实行的是浅拷贝.对象某个属性值为对象时,拷贝得到的仅为该对象的引用.

#### 常见用途
* 为对象添加属性

```
let a = {};
Object.assign(a,{x:1});
console.log(a); //=> {x:1}
```

* 为对象添加方法

```
let a = {};
let b = {
    test(){
        console.log(1);
    }
};
Object.assign(a, b);
```

* 克隆对象

```
function clone(origin){
    return Object.assign({}, origin);
}
```

* 合并多个对象

```
const merge = (target, ...sources) => Object.assign(target, ...sources);
const merge = (...sources) => Object.assign({}, ...sources);
```

* 为属性指定默认值

```
const DEFAULTS = {
    count: 0,
    length: 0
};
let setValue = (options) => Object.assign({}, DEFAULTS, options);
```

## 属性的可枚举性

`Object.getOwnPropertyDescriptor`方法可获取该属性的描述对象,描述对象的`enumerable`属性成为可枚举性  
`ES5`的三个操作会忽略不可枚举的属性
* `for...in`循环:只遍历对象自身和继承的可枚举的属性
* `Object.keys()`: 返回对象自身所有可可枚举的键名
* `JSON.stringify()`: 只串化对象自身的可枚举的属性

`ES6`的`Object.assign()`也会忽略不可枚举的属性

> `ES6`规定,所有`Class`的圆形的方法都是不可枚举.

## 属性的遍历