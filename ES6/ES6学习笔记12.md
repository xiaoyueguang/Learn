# Set和Map数据结构
`Set`和`Map`都是ES6提供的新两者的数据结构,两者的成员值都是唯一的,没有重复的值  
两者本身也是构造函数

## Set
`Set`类似于数组,成员的值唯一,可通过`add`的方法添加成员,也可以接受一个参数来完成初始化

```
const s = new Set()
[1, 2, 3, 4, 4, 5, 3, 2].map(data => s.add(data))
console.log(s)  //=> Set{1, 2, 3, 4, 5} 过滤了重复的值
s.size  //=> 5

const S = new Set([1, 2, 3, 4, 4, 5, 3, 2])
console.log(S)  //=> Set{1, 2, 3, 4, 5} 过滤了重复的值
S.size  //=> 5
```

> 利用 `Set`**成员的值唯一** 这一特性,可通过下面的方法来给数组去重

```
function dedup (arr) {
    return [... new Set(arr)]
}

const arr = [1, 2, 3, 2, '1']
console.log(dedup(arr)) //=> [1, 2, 3, '1']
```
在`Set`的数据结构中, `NaN`是被当成相同的值,两个对象是不相等的,数组也是不想等的
```
const s = new Set()
s.add(NaN)  //=> Set(NaN)
s.add(NaN)  //=> Set(NaN)
s.add([])   //=> Set(NaN, [])
s.add([])   //=> Set(NaN, [], [])
s.add({})   //=> Set(NaN, [], [], {})
s.add({})   //=> Set(NaN, [], [], {}, {})
s.add(undefined)   //=> Set(NaN, [], [], {}, {}, undefined)
s.add(undefined)   //=> Set(NaN, [], [], {}, {}, undefined)
s.add(null)   //=> Set(NaN, [], [], {}, {}, undefined, null)
s.add(null)   //=> Set(NaN, [], [], {}, {}, undefined, null)
```
#### Set实例的属性和方法
1. `Set.prototype.constructor`:构造函数
2. `Set.prototype.size`: 返回`Set`实例的成员总数
3. `add(value)`: 添加值,返回本身
4. `delete(value)`: 删除某个值,返回布尔值,表示删除是否成功
5. `has(value)`: 返回布尔值,表示该值是否为`Set`的成员
6. `clear()`: 清除所有成员,无返回值
7. `keys()`: 返回键名的遍历器
8. `values()`: 返回键值的遍历器
9. `entries()`: 返回键值对的遍历器
10. `forEach()`: 使用回调函数遍历每个成员

`Set`的遍历顺序与插入顺序是相同的.  
由于`Set`结构没有键名,只有键值.因此他的`keys()`和`values()`行为是完全一样的  
`foreach()`可以对每个成员执行某个操作
```
const s = new Set([1, 2, 3])
console.log(s.keys())		//=> SetIterator { 1, 2, 3 }
console.log(s.values())		//=> SetIterator { 1, 2, 3 }
console.log(s.entries())	//=> SetIterator { [ 1, 1 ], [ 2, 2 ], [ 3, 3 ] }
s.forEach(data => console.log(data))	//=> 1, 2, 3
```

## WeakSet

## Map

## WeakMap